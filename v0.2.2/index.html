<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The PeaceFounder&#39;s project · PeaceVote.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PeaceVote.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>The PeaceFounder&#39;s project</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#The-design-of-PeaceVote-1">The design of PeaceVote</a></li><li class="toplevel"><a class="toctext" href="#How-to-use-PeaceVote-1">How to use PeaceVote</a></li><li><a class="toctext" href="#Passive-exploration-1">Passive exploration</a></li><li><a class="toctext" href="#Participation-1">Participation</a></li><li class="toplevel"><a class="toctext" href="#How-to-set-it-up?-1">How to set it up?</a></li><li class="toplevel"><a class="toctext" href="#References-1">References</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>The PeaceFounder&#39;s project</a></li></ul><a class="edit-page" href="https://github.com/PeaceFounder/PeaceVote.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>The PeaceFounder&#39;s project</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="The-PeaceFounder&#39;s-project-1" href="#The-PeaceFounder&#39;s-project-1">The PeaceFounder&#39;s project</a></h1><p>Online voting systems had been active research problem since the discovery of asymmetric cryptography. However, none to my knowledge is trustworthy. It is easy to imagine a software-independent system where anonymity is disregarded by having a public ledger to which one submits their signed votes. But the anonymity is essential to the integrity of elections! Or one imagines a software which is perfect and so preserves anonymity while being secure. However, what if a villain takes over the server and replaces the software with its own?</p><p>There are many metrics which had been introduced for measuring the trustworthiness of the electronic voting system. I propose to group them into three categories - transparency, security and anonymity. Which are easy to remember through existing technologies:</p><ul><li>security + anonymity: Trust the system X doing Y. Most electronic voting systems fit into this category, for example, the Estonian system. Their Achilles heel is the software dependance.</li><li>security + transparency: Trust the voter X being independent of Y. Such a voting system makes sense when X is representative of Y. However, for ordinary citizens, this is inappropriate as that enables easy coercion, shaming and bribery. </li><li>transparency + anonymity: Trust X not doing Y. These are all voting systems to which you can authorize with anonymous means. The best example would be a privately generated bitcoin by a PoW which acts as a token for a vote to be transferred to an account A, B and C representing a choice.</li></ul><p>More specifically, I propose to fix the definitions for anonymity, transparency and security as follows:</p><h3><a class="nav-anchor" id="Transparency:-1" href="#Transparency:-1">Transparency:</a></h3><ul><li>Open source and open participation</li><li>Software independence. If someone hacks in the system and replaces that with his own, he shall not be able to change an election outcome without being detected. (I apply this notion here as that the collected data would not change, so it does not overlap with verifiability.)</li><li>Individual verifiability. See proof how you voted and that you were counted.</li><li>Universal verifiability. Fairness and accurateness can be proved from publically available data.</li></ul><h3><a class="nav-anchor" id="Security:-1" href="#Security:-1">Security:</a></h3><ul><li>Legitimacy. All participating members are real and verified. </li><li>Accountabilty. Misbehaving individuals can be isolated. </li><li>Tamper resitant. The publically available data can not be tampered with to change the election outcome. (cryptographically secure)</li><li>No single attackable entity (phone, server, cryptographic protocol, ....) which can significantly change the election outcome. (There is always a possibility of malware. I assume that it is a minority and the detection and prevention of that is the Vendor&#39;s responsibility whose reputation would be at stake.)</li></ul><h3><a class="nav-anchor" id="Anonymity:-1" href="#Anonymity:-1">Anonymity:</a></h3><ul><li>Privacy: Noone knows how you voted without your cooperation.</li><li>Secrecy: You can not prove how you voted for another person, even with your cooperation, also known as receipt freeness and secret ballot. I don&#39;t use those definitions because the voting system can have a receipt, but it might not be the only one. The voter might have a secret!</li></ul><p>Secrecy can be implemented with software by giving the citizen a choice to vote in a traditional voting ceremony which would override the online voting receipt while not revealing whether he/she did so to the public. In such a case, the system needs a trusted auditor who produces a compensated tally. It seems reasonable to assume that the secret ballot would be much smaller than a public (not open) ballot thus universal verifiability would still hold approximatelly. However, before, that is reasonable to implement one needs to prevent such a simple thing as identity selling which one could achieve with hardware (see the PeaceCard project). </p><p>The focus thus for PeaceVote is voluntarily democracies. It is the democracies of communities where members get engaged by making a significant change in their surroundings and so would want to protect their democracy. The privacy would make decisions less group biased and more thoughtful by individuals themselves for the community. The democracy could also be a great tool to unite audiences of two opposing divisions of the society by giving them the ability to delegate representatives for a discussion.  The system is also useful for anonymous questionnaires where the minority members do not feel safe to be publically known. Or for whistleblowers who do feel that their integrity had been intact. The last part is essential to punish those members who are documented to sell their votes on the field or sell their representative power within the community. </p><h1><a class="nav-anchor" id="The-design-of-PeaceVote-1" href="#The-design-of-PeaceVote-1">The design of PeaceVote</a></h1><p>The design of PeaceVote voting system as basis uses a thought experiment. Imagine that you go to elections, register with a gatekeeper and enter the ballot cabin with the envelope. Now instead of selecting candidates, you put in a public key which you have generated in secret and put the envelope in that ballot box. The keys public keys collected that way would have a great property: anonymity and legitimacy. Those keys then allow doing anonymous, transparent and secure electronic voting.  </p><p>But of course, life is not simple, and no one would try to explain to an ordinary person what the public key is and how to securely generate that. Instead, we need to have an electronic voting system to get anonymous keys for electronic voting. Right, that is a tautology. Can we do better?</p><p>Let&#39;s consider an electronic ballot server which does have some reason of trust, is secure and anonymous by design. Multiple people would participate and would form a ballot. The server would randomize the ballot and publish that. Since the server is like a black box is there anything else what we can do to increase the trust of the result? In the end, we do not want to lose the ability to vote.</p><p>We can validate ballot! Every participating member must sign the ballot to confirm that his newly generated key is there. If everyone signs the ballot, we form a braid which connects old input keys with new output keys. In this way, we for sure, know that the system is secure. Whereas the anonymity of new keys is guaranteed by having trust in the system and depends on the ballot protocol used.  However, there is a pressing issue with such a design. What if a participating member refuses to sign the ballot? Shall we consider him a victim or a villain? Since the relation between input and output is lost, we can not give any knowledge on the issue. Such an electronic voting system is simply not accountable and scales badly as we increase the number of participants.</p><p>The idea I am proposing is to do multiple small ballots, which we can retry quickly in case a participant refuses to sign the ballot, and chain them together to braid anonymity. This is the idea of the BraidChain which firstly allows scaling of unaccountable voting systems and secondly offers a natural extension for distributing the trust of anonymity over multiple participating ballot servers. Thus, in the end, we obtain the list of anonymous and legitimate keys which allows us to do secure, anonymous and transparent electronic voting. </p><h1><a class="nav-anchor" id="How-to-use-PeaceVote-1" href="#How-to-use-PeaceVote-1">How to use PeaceVote</a></h1><p>There is an infinite variation in which one could make the voting system I described above from cryptographic protocols to a policy how new members are accepted and how votes are counted - quadratically, cumulatively or as in liquid democracy. A nightmare for the programmer to offer all these variations in a single package and a nightmare for the community. This is why PeaceVote is modular, and each community maintains the module which defines how to register, braid and vote. </p><p>One such community is <code>Community.jl</code> which we add as an ordinary package:</p><pre><code class="language-none">using Pkg
Pkg.add(&quot;Community.jl&quot;)</code></pre><p>which good to know we get securely with the help of certified authority certificates and Diffie-Hellman key exchange. </p><p>Let&#39;s assume that the Community server is running so I could walk through the user perspective. The user does the following thing to start using the community:</p><pre><code class="language-none">using PeaceVote
setnamespace(@__MODULE__)
import Community</code></pre><p>The <code>setnamespace</code> method allows the PeaceVote module to see the imported modules in the present namespace. This allows <code>PeaceVote</code> to be as small as possible for the junction work it does while also offering higher-order abstractions, for example, to make module containerized.  Currently, when one imports any community, one trusts that the code will not steal the keys and send them over the network.</p><h2><a class="nav-anchor" id="Passive-exploration-1" href="#Passive-exploration-1">Passive exploration</a></h2><p>First, we can explore community passively. For doing that we need to get UUID of the Community, which in this case happens to be:</p><pre><code class="language-none">uuid = PeaceVote.uuid(&quot;Community&quot;)</code></pre><p>Then we can get a handle for the community module with <code>community</code> method which tries to access already loaded module from the namespace:</p><pre><code class="language-none">com = community(uuid)</code></pre><p>which returns the community module and informs the user whether PeaceVote Community API is supported. Internally community is used to <code>unwrap</code> signed data from other communities; thus UUID felt like a right handle. The <code>com</code> variable now holds the community module (which incidentally happens to be Community), and now one can investigate the community. </p><p>The first thing we do is to synchronize the community data with us locally:</p><pre><code class="language-none">PeaceVote.sync(uuid)</code></pre><p>which will download the ledger locally by the community specified method in the folder <code>PeaceVote.datadir(uuid)</code>. </p><p>When all data is downloaded, we can start to investigate the BraidChain by first loading it:</p><pre><code class="language-none">braidchain = PeaceVote.braidchain(uuid)</code></pre><p>This loads all data associated with the community, cryptographically verify that it is correct and return a list of messages containing information which let new members inside the community, braids, proposals, and votes in the order which they were registered.   </p><p>The braidchain elements are standardized by PeaceVote to enable uniform postprocessing. For example, we may ask the question of the set of participating member public keys. That we can easily get with <code>PeaceVote.members(braidchain)</code>; a current list of anonymous identities <code>PeaceVote.voters(braidchain)</code>; a set of all voters <code>PeaceVote.allvoters(braidchain)</code>; and significantly a set of all proposals in the system <code>PeaceVote.proposals(braidchain)</code>, let&#39;s explore those further.</p><p>A proposal is an item in the ledger which is included in the ledger by policies laid out by the community. (In one case one may want a community where every member is allowed to submit their proposal in another case only community elected representatives are allowed to submit the proposals.) The proposal contains the message of the proposal <code>proposal.msg</code> and options <code>proposal.options</code> which is simply a list of choices. </p><p>The set of voters eligible to vote on the proposal is defined as the current list of anonymous identities at the time when the proposal was added to the ledger. Let&#39;s assume that we have a <code>proposal::Proposal</code>. To obtain the list of eligible voters, we can use </p><pre><code class="language-none">PeaceVote.voters(braidchain, proposal)</code></pre><p>which is also essential for counting the votes as well. </p><p>The last part we shall discuss of passive analysis of braidchain is counting. Each community is expected to use its own counting method for the votes. For example, the community may choose ordinary, cumulative, quadratic or preferential voting or even supporting multiple ways indicating that in the voting message. To obtain the tally for the <code>proposal::Proposal</code> one does:</p><pre><code class="language-none">PeaceVote.count(uuid, proposal, braidchain)</code></pre><p>Returning a number for every option provided by the proposal. </p><h2><a class="nav-anchor" id="Participation-1" href="#Participation-1">Participation</a></h2><p>Let&#39;s say that we are interested in taking part in the community. How can we do that? First, we need to generate a private and public key pair:</p><pre><code class="language-none">member = PeaceVote.Member(uuid)</code></pre><p>This loads a community with <code>community(uuid)</code> method, and from the community load a <code>Signer()</code> method and finally stores the key at <code>PeaceVote.keydir(uuid)</code>. If the key is already generated, then it is just loaded from the disk. </p><p>The next important step is to register the <code>member.id</code> with the community.  From the community perspective, the most pressing issue is whether they can prove that a new member is a real person. In an ideal world, each of us would have a state-issued ID card where identities would be published in a publically accessible ledger. Then one would just be able to sign the key which then the community would be able to accept from a legitimacy point of view. </p><p>Unfortunately, we are not living in such a world. What we can do, however, is having a certifying authority which verifies your identity and signs your key on such a basis. Such a certifying authority can be an algorithm which gives a certificate of your identity derived from your FaceBook, Twitter, GitHub, etc. identities. Or it can be an actual person who verifies you in person or over a conversation online. Or it can be you signing the key by already certified key. In the end, how new members are approved is up to the community itself who specifies Web of Trust. </p><p>PeaceVote models this process as follows. The potential member first creates his identity:</p><pre><code class="language-none">identification = PeaceVote.ID(&quot;name&quot;, &quot;date&quot;, meber.id)</code></pre><p>He/She then send that to a certifying authority who approves signs that and so creates a certificate:</p><pre><code class="language-none">certificate = PeaceVote.Certificate(identification,authority)</code></pre><p>Because the authority could come from a different community and so use a different set of cryptographic protocols the UUID is encoded in the certificate additionally with ID. One can then verify the correctness of the signature with <code>PeaceVote.unwrap(certificate)</code>. After the certificate had been obtained, one can register and so become a member of the community:</p><pre><code class="language-none">PeaceVote.register(uuid,certificate)</code></pre><p>When we are registered, the next important step is to braid for anonymity. To do so, one creates a <code>KeyChain</code> which name implies contains a chain of keys for the community:</p><pre><code class="language-none">keychain = PeaceVote.KeyChain(uuid)</code></pre><p>The keychain contains a <code>keychain.member</code> and <code>keychain.signers</code> and <code>keychain.uuid</code>. The signers are all anonymous identities in chronological order. </p><p>The braiding can be executed as follows:</p><pre><code class="language-none">PeaceVote.braid!(keychain)</code></pre><p>During the execution of this command, the community is loaded from UUID, a new signer is generated and the braiding procedure is executed. If it is successful, the key is not removed from the storage, and a key is added to the list of signers. This procedure can be repeated as often as one wishes until sufficient anonymity is braided. </p><p>The last part of participation essentials is voting. To do so one gets picks a proposal from the BraidChain and makes a choice by creating an <code>Option</code> message:</p><pre><code class="language-none">option = PeaceVote.Option(proposal, 2)</code></pre><p>which means that we have chosen <code>proposal.options[2]</code>. Then the last step is to deliver the vote with the right voting key, which can be done as follows:</p><pre><code class="language-none">PeaceVote.vote(option,keychain)</code></pre><p>Some of the members (or all) would be eligible to make a voting proposition. That they can do simply with a command:</p><pre><code class="language-none">PeaceVote.propose(&quot;Found peace for a change?&quot;, [&quot;yes, &quot;no&quot;, &quot;maybe&quot;], member)</code></pre><p>which will deliver the proposal to the community (encoded in member.uuid) server(s) and perform the vote. </p><h1><a class="nav-anchor" id="How-to-set-it-up?-1" href="#How-to-set-it-up?-1">How to set it up?</a></h1><p>To enable the use of PeaceVote, the community needs to support an extensive API. The list of methods and variables which must be a part of the community is as follows:</p><pre><code class="language-none"># For analysis
sync
braidchain
count

# For participation
Signer 
Signature 
verify ### verifies signature with respect to data
id ### method for the Signer and for the Signature
register
braid
vote

# For intercommunity communication
G
SecureSocket
hash</code></pre><p>Currently <code>id</code> and <code>verify</code> appears at very much at the same places. In future <code>id</code> will be deprecated in favour of <code>verify</code> which returns <code>id</code> if signature is valid and <code>nothing</code> otherwise.</p><p>For an example of the community see <code>Community.jl</code>, and for convenience, methods see <code>PeaceFounder.jl</code> package. But mainly it is up to you to build the voting tool you need for the community whereas PeaceVote helps your community to be more accessible, distributed and transparent.</p><h1><a class="nav-anchor" id="References-1" href="#References-1">References</a></h1><p>After I finalized the design and found it trustworthy from my perspective, I tried to research shit of existing systems, the values and general criticisms of electronic voting. For example, I discovered that <code>SynchronicBallot.jl</code> which is the system I developed as part of functional <code>Community.jl</code> turns out is not very novel as it is a mixnet combined with kind of a blind signature scheme and was remarkably used to my surprise for Bitcoin in part of CoinJoin project and derivatives. Perhaps my contribution here was an extra validation step, but I don&#39;t know for sure. These are, in my opinion, the most important references I have found so far about electronic voting:</p><ul><li>https://www.youtube.com/watch?v=LkH2r-sNjQs</li><li>https://www.youtube.com/watch?v=abQCqIbBBeM&amp;feature=emb_title</li><li>https://en.wikipedia.org/wiki/Software_independence</li><li>https://en.bitcoin.it/wiki/CoinJoin</li><li>https://arxiv.org/pdf/1707.08619.pdf</li><li>https://usvotefoundation-drupal.s3.amazonaws.com/prod/E2EVIV<em>full</em>report.pdf</li><li>https://www.nap.edu/catalog/25120/securing-the-vote-protecting-american-democracy [section about blockchain]</li></ul><footer><hr/></footer></article></body></html>
